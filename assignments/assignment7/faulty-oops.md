The output on entering ` echo "hello_world" > /dev/faulty ` is 
```
Starting dropbear sshd: OK
Loading misc-modules and scull
hello: loading out-of-tree module taints kernel.
Hello, world
Anshul-99
Load our module, exit on failure
faulty: unknown parameter 'faulty' ignored
Get the major number (allocated with allocate_chrdev_region) from /proc/devices
Remove any existing /dev node for /dev/faulty
Add a node for our device at /dev/faulty using mknod
Change group owner to staff
Change access mode to 664
scullsingle registered at f900008
sculluid registered at f900009
scullwuid registered at f90000a
scullpriv registered at f90000b
Starting aesdsocket

Welcome to Buildroot
buildroot login: root
Password: 
# echo "hello_word" > /dev/faulty
Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000 
Mem abort info:
  ESR = 0x96000046
  EC = 0x25: DABT (current EL), IL = 32 bits
  SET = 0, FnV = 0
  EA = 0, S1PTW = 0
Data abort info:
  ISV = 0, ISS = 0x00000046
  CM = 0, WnR = 1
user pgtable: 4k pages, 39-bit VAs, pgdp=0000000041fc4000
[0000000000000000] pgd=0000000041fc7003, p4d=0000000041fc7003, pud=0000000041fc7003, pmd=0000000000000000
Internal error: Oops: 96000046 [#1] SMP
Modules linked in: scull(O) faulty(O) hello(O)
CPU: 0 PID: 151 Comm: sh Tainted: G           O      5.10.7 #1
Hardware name: linux,dummy-virt (DT)
pstate: 80000005 (Nzcv daif -PAN -UAO -TCO BTYPE=--)
pc : faulty_write+0x10/0x20 [faulty]
lr : vfs_write+0xc0/0x290
sp : ffffffc010bcbdb0
x29: ffffffc010bcbdb0 x28: ffffff8001fe8c80 
x27: 0000000000000000 x26: 0000000000000000 
x25: 0000000000000000 x24: 0000000000000000 
x23: 0000000000000000 x22: ffffffc010bcbe30 
x21: 00000000004c9940 x20: ffffff8002089500 
x19: 000000000000000b x18: 0000000000000000 
x17: 0000000000000000 x16: 0000000000000000 
x15: 0000000000000000 x14: 0000000000000000 
x13: 0000000000000000 x12: 0000000000000000 
x11: 0000000000000000 x10: 0000000000000000 
x9 : 0000000000000000 x8 : 0000000000000000 
x7 : 0000000000000000 x6 : 0000000000000000 
x5 : ffffff800201d7b8 x4 : ffffffc008675000 
x3 : ffffffc010bcbe30 x2 : 000000000000000b 
x1 : 0000000000000000 x0 : 0000000000000000 
Call trace:
 faulty_write+0x10/0x20 [faulty]
 ksys_write+0x6c/0x100
 __arm64_sys_write+0x1c/0x30
 el0_svc_common.constprop.0+0x9c/0x1c0
 do_el0_svc+0x70/0x90
 el0_svc+0x14/0x20
 el0_sync_handler+0xb0/0xc0
 el0_sync+0x174/0x180
Code: d2800001 d2800000 d503233f d50323bf (b900003f) 
```
When an invalid pointer is dereferenced, the paging mechanism fails to map the pointer to a physical address and the processor signals a page fault to OS. If the kernel is unable to page in the address, the kernel generates an oops if the processor is in the supervisor mode. If this happens in kernel code, it will always result in an oops.

The output gives us an indication that the oops was caused due to dereferencing a NULL pointer. The following statement shows that. 
`Unable to handle kernel NULL pointer dereference at virtual address 0000000000000000`

The message was generated by writing to a device owned by faulty module. 
In the faulty module, the function was faulty_write()
This is shown by 

`pc : faulty_write+0x10/0x20 [faulty]`

and also the call trace. 
```
Call trace:
 faulty_write+0x10/0x20 [faulty]
 ksys_write+0x6c/0x100
 __arm64_sys_write+0x1c/0x30
 el0_svc_common.constprop.0+0x9c/0x1c0
```

`pc : faulty_write+0x10/0x20 [faulty]`
This also shows that the instruction counter is 16 bytes into the function when the fault occured and the function is total 32 bytes long. 

